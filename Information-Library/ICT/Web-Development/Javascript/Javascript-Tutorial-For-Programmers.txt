Javascript Tutorial For Programmers
========================================================================================================================

@author     Sami Somero <ssomero@gmail.com>
@date       19.03.2019
@version    0.96
@revision   0.2
@license    Published under Creative Commons License Attribution-NonCommercial-ShareAlike 3.0 Unported (CC BY-NC-SA 3.0)
            You are free:
                to Share — to copy, distribute and transmit the work
                to Remix — to adapt the work
            Under the following conditions:
                Attribution   — You must attribute the work in the manner specified by the author or licensor (but not
                                in any way that suggests that they endorse you or your use of the work).
                Noncommercial — You may not use this work for commercial purposes.
                Share Alike   — If you alter, transform, or build upon this work, you may distribute the resulting work
                                only under the same or similar license to this one.
            With the understanding that:
                Waiver        — Any of the above conditions can be waived if you get permission from the copyright
                                holder.
                Public Domain — Where the work or any of its elements is in the public domain under applicable law, that
                                status is in no way affected by the license.
            Other Rights      — In no way are any of the following rights affected by the license:
                                * Your fair dealing or fair use rights, or other applicable copyright exceptions and
                                  limitations;
                                * The author's moral rights;
                                * Rights other persons may have either in the work itself or in how the work is used,
                                  such as publicity or privacy rights.
            Notice            — For any reuse or distribution, you must make clear to others the license terms of this
                                work.
            For details and the full license text, see http://creativecommons.org/licenses/by-nc-sa/3.0/

========================================================================================================================

=================
=== Own Notes ===
=================

* Advanced
* Glossary
* References
* Optimization?
* Element.scrollTop() // DOM Example
* 12. Security tips -> v2.0
* Levityspaikkana GitHub
* JSONP kakkos versioon?
* Interaktiivisia esimerkkejä?
* Contents pitää olla - kännykästä tuttu ||| menu vasemmassa yläreunassa
* Graafiseen ulkoasuun panostaminen koska nykypäivänä niin iso asia
* Bonus osio web 2.0 -> v2.0
* Bonus osio: XSS ym. tietoturvat -> v2.0

TODO/EXTRAS:
Google chrome:
console.log / console.info / console.error jne. console.log(param1, param2) <- css style with using %c!

%s  Formats the value as a string
%i or %d  Formats the value as an integer
%f  Formats the value as a floating point value
%o  Formats the value as an expandable DOM element. As seen in the Elements panel
%O  Formats the value as an expandable JavaScript object
%c  Applies CSS style rules to the output string as specified by the second parameter

https://developers.google.com/web/tools/chrome-devtools/console/console-reference

DOM: Element position: element.getBoundingClientRect() - returns DomRect Object with properties:
* top, right, bottom, x, y, width, and height. values are in pixels

Looping through array with for/in control structure:

var myArray = [1, "test", 2];
for(i in myArray) {
   console.log(i + ':' + myArray[i]);   // Outputs:
                                        // 0:1
                                        // 1:test
                                        // 2:2

}

BOM: get viewport size: window.innerHeight; and window.innerWidth; properties

      var myObj = {name:"Hunter S. Thompson"}, mySecondObj = {name:"Timothy Leary"};

      Object.freeze(myObj);
      console.log('myObj is frozen: ' + Object.isFrozen(myObj) + ' / ' + 'mySecondObj is frozen: ' + Object.isFrozen(mySecondObj));

    Console output:
     myObj is frozen: true / mySecondObj is frozen: false

extra for strings:
                 JavaScript also assigns several properties when string variable is created:

length          // string.length is a getter property and returns count of characters in string starting count from 1
charAt()        // returns character UTF Code Unit at given position as argument. Same as str[position]
charCodeAt()    // returns character UTF Code unit as given position as argument in numeric value
codePointAt()   // returns character UTF Code Point as a numeric value
repeat()        // repeats string x times where x is the argument given to repeat() method
startsWith()    // returns boolean value for finding a needle from string. First argument is needle, second is optional index where to start
endsWith()      // same as above but tries to find needle at the end of the string
indexOf()       // searches given string and returns zero based index position. First argument is needle, second is optional index where to start
lastIndexOf()   // same as above but starts searching from the end of haystack
match()         // regular expression search from haystack. Returns array of found matches or null if not found
replace()       // replace haystack contents with given value. First argument is a regular expression to search for and second is either
                   a string or a function. If needle is not found, returns the original haystack
search(searchvalue)        // finds a needle in haystack. Argument is regular expression, return value is index of needle if founded, -1 otherwise
slice()         // returns a substring from a haystack. First argument is zero based starting point and second is zero based ending point
split()         // splits string into substrings and returns array. First arguments is regular expression, second optional argument is
                   how many times string should be split
toUpperCase()   // returns string converted all characters to upper case
toLowerCase()   // returns string converted all characters to lower case
trim()          // removes whitespaces from the beginning and end of string
localeCompare() // checks whether given argument comes after or before original string in alphabetical order. Second optional argument
                   is BCP-47 language tag like "en-US"
substring(start, end)
fromCharCode(charCode)

var str = "This is a string";
console.log( str.length );   // Outputs "16"

=== Contents ===
1. About JavaScript tutorial for programmers
2. Introduction to JavaScript basics
2.1 Implementing JavaScript to HTML document
2.2 Basic syntax
2.2.1 Operators
2.3 Variables
2.3.1 Primitive data types
2.3.2 Variable scope
2.3.3 Arrays and Sets
2.3.4 Type casting
2.3.5 Control structures
2.3.6 Error handling
3. Functions
4. Classes and Objects
4.1 Prototype Chain
4.2 Proxies
4.3 Usefull objec properties/methods
5. HTML DOM (Document Object Model)
5.1 HTML DOM Basics
5.2 HTML DOM Events
6. BOM (Browser Object Model)
6.1 BOM Specific objects
7. AJAX and JSON
7.1 JSON (JavaScript Object Notation)
7.2 AJAX
8. Extras (RegExp, Cookies...)
8.1 Regular Expressions
8.2 Cookies
9. References

====================================================
=== 1. About JavaScript tutorial for programmers ===
====================================================

This tutorial is written for programmers who have prior experience of some programming or scripting language and want to learn
JavaScript syntax. I will be comparing JavaScript syntax to other common programming/scripting languages syntaxes throughout this
tutorial (like C++ or PHP for example) and because of this approach, this tutorial is not suitable for beginners without
general knowledge of programming.

I started writing this tutorial because I was updating my own JavaScript skills and after looking at my vast amount of notes that
I have gathered in past years, I made a decision; why not convert them to a tutorial -style book and share my knowledge with the
rest of the world. This is the interactive version of my tutorial and requires a web browser and JavaScript permission from your
browser to view and function properly. You can also view this tutorial with your smartphone or tablet as I have made this also
mobile friendly.

For this tutorial, I have chosen ECMAScript (edition) 6 or known as other names: ES6 and ECMAScript 2015. Reason for this is that
the time I am writing this book, ES6 is widely accepted and impelemented in almost all modern browsers.

This tutorial will teach basics of JavaScript language syntax, some advanced features language has to offer and how to avoid common
pitfalls. Some of the functionality that can be achieved using HTML or CSS (like responsive fonts) are intentionally implemented with
JavaScript for syntax learning purposes.

This tutorial also includes how to use browsers debugging tools and some other things that might step out of scope of JavaScript syntax
but are good to know for web developer. You can also use this tutorial as a cheat sheet for ECMAScript 6. By the end of this tutorial
book, you should have familiarized yourself with common concepts of using basic JavaScript syntax without any external libraries or
frameworks.

With basic knowledge of JavaScript syntax, I did create my own small framework with pure JavaScript for this tutorial and also so that
I can use it to release interactive versions of other topics in the future easily. You can always check the main JavaScript file to
see how I implemented it.

Prerequisites: Basic understanding of programming in general, basics of HTML and CSS syntax, web browser with JavaScript enabled and
optionally cookies allowed for storing settings.

Tested with following browers: [List of browsers and their versions]

You can find help how to navigate through this interactive book by using the question mark icon at the left side menu bar. Happy
Learning!


Author
-------

TrueIndividual

I have been involved in ICT since childhood and my thirst for knowledge has given me good skills, especially for this field.
I consider myself as a real programmer but I got a job which involved making web applications so i started focusing more and
more to web developing. After reading and assimilating the basics of web developing languages (HTML, CSS and JavaScript) and
server side requirements for web applications including relational database (MySQL) and server side scripting language (PHP),
I wrote my first webshop and a cash register system.

I have been a web developer over 10+ years and have also used Content Management Systems like Joomla, Drupal, WordPress etc.

Even though I am interested in wide range of IT areas including making apps with Java language for Android,
reverse engineering, security field, building computers from components etc. this book is for learning basic JavaScript syntax.

This is also a good opportunity for me to practise my written English skills (English is not my native language)
and creating a tutorial format book from my notes and knowledge. All questions, improvement ideas and noticing typos or otherwise bad
English, is more than welcome and can be send to my e-mail address that you can find from the left side menu bar using info icon
(or just reading included JavaScript file's header comment information).

As last words, I usually compare programming (or scripting) to cars. Car has intention: to get you from place A to B.
Programs also have an intention. You can build a car from scratch with parts or use already made car. If you have knowledge
to understand how your car parts work, you can create your own car or customize your existing one to be more suitable for
your needs. So with this analogy, I design and build cars, choose right parts and motor for it but I don't do the paint
job for the car which is a profession of it's own. That is a nice way to compare my ugly UI which leaves no doubt that I did
not have a graphics designer for this project ;)

"There he goes. One of God's own prototypes. A high-powered mutant of some kind. Never even considered for mass production. Too weird
to live, and too rare to die." - Hunter S. Thompson, Fear and Loathing in Las Vegas


============================================
=== 2. Introduction to JavaScript basics ===
============================================

Brief History
-------------------------------------------------

JavaScript was developed for Netscape browser by Brendan Eich in 1995 and became an Ecma(European Computer Manufacturers Association)[ref.1]
standard in 1997. ECMA-262 is the official name of the standard. ECMAScript is the official name of the language.

The first browser to run JavaScript was Netscape 2 in 1996. Microsoft developed its own scripting language for HTML called JScript in 1996 by
reverse-engineering JavaScript to be used at Internet Explorer web browser.

By the time of writing this, ECMAScript latest version number (Edition) is 9 (ECMAScript 2018). ECMAScript also uses year as a synonym name,
starting from edition 6 (ECMASCRIPT 2015 or ES2015).

Usage
-------------------------------------------------

JavaScript is used in conjuction with HTML language to add dynamicality to static web page via users browser (ie. browser side scripting).
With JavaScript you can dynamically change HTML web page content. You can add/remove/mofidy HTML element(s)/node(s) and their properties.
As name suggests, JavaScript is not a real programming language but a scripting language. Nowadays it is also increasingly used for
writing server applications using Node.js runtime environment.

Using browsers console
-------------------------------------------------

I will be using most examples by writing to browsers JavaScript debugging console so when you see a comment saying "Outputs", I mean what
is written to console. If your browser supports debugging tools, you can try F12 to bring it up or go to browsers menu and try to find
"Developer Tools", "Web Developer" or similar depending of browser.

* console.log(oMessage)
    Description:    Evaluates and writes message parameter to browsers console
    Parameters:     oMessage (optional) - Mixed
    Return value:   undefined
    Example usage:

      console.log('Hello World');

    Console output:
     Hello World

=== 2.1 Implementing JavaScript to HTML document ===

You can implement JavaScript in two ways: either inline code or external file. Whichever you choose, you will use HTML <script> Tag
that can be inserted either inside <head> or <body> sections in HTML document.

Example of Inline implementing:

<script>
  alert('Hello World!');  // Display a popup (alert) window with text "Hello World!"
</script>

JavaScript file has a .js file extension. To add external Javascript file, use attribute "src" with either relative or full URL
path in <script> Tag.

Example of external implementation:

<script src="js/myScript1.js"></script>                           // Relative path, script resides in "js" sub directory of domain
<script src="http://www.mydomain.com/js/myScript2.js"></script>   // Full URL path to JavaScript file


=== 2.2 Basic syntax ===

JavaScript syntax is quite close to C++/PHP languages with it's own differences of course. If you have prior knowledge of either
language, you should be able to read JavaScript without heavy difficulties. Even though JavaScript is heavily object oriented,
it doesn't have classes per se but uses instead objects with prototype chain which we will discuss later.

Commenting code in JavaScript
-------------------------------------------------

JavaScript uses C++ style commenting so for one line comment, use two forward slashes (//):

  var myVar = 4; // Everything after these two forward slashes are comment in one line

For multiline commenting, use forward slash and asterisk (/*) to start comment block and asterisk and forward slash (*/) to end comment block:

  var myVar = 4;
  /* Common way to debug code by commenting some of it
  myVar += 4;
  console.log(myVar);
  */

-------------------------------------------------
2.2.1 Operators
-------------------------------------------------

Basic operators
----------------
In JavaScript, the plus (+) operator can be used for three purposes: type casting string to number, concatenating two strings or
normal add operator.

+ "4"   // Type casts string "4" to number 4
1 + 1   // Normal add operator. Returns number 2
"1" + 1 // Concatenates strings with automatic type casting. Returns string "11"

As a string concatenate operator, if atleast one operand is string type, return type will be string. JavaScript syntax
allows + operator to be repeated with a space between it:

+ + + "1"   // Returns number 1

Even though a little bit confusing, first plus (+) operator type casts string "1" to number 1. Second and third plus (+)
operator does the same so result remains same if we would have used only one plus (+) operator.

The minus (-) operator can be used for two purposes: as an unary operator so it inverts number sign, otherwise
it acts as a normal minus operator during number calculations. Type casting is done if string can be converted to a number.
As plus (+) operator, also minus (-) operator can be repeated with spaces between it:

- -1             // Inverts number -1 to 1
- - -1           // Inverts number -1 two times so first it becames +1, then -1 again
+ "1" - - - -1   // Type casts string "1" to number 1, then inverts -1 number to 1 and adds both up returning number 2
- "-1"           // Returns 1 as a number type

NOTE: In math two minuses equal plus so the operator minus (-) two times separated by space equals plus operator (+).

Other basic operators that are familiar from other programming languages:
*                     - Multiply left hand operand with right hand operand
/                     - Divide left hand operand with right hand operand
%                     - Modulo. Divides left hand operand with right hand operand and returns remainder after division
++                    - Increment value by one. Can be used as a left hand or right hand operand
--                    - Decrease value by one. Can be used as a left hand or right hand operand
<=                    - Less or equal than left hand operand
>=                    - Greater or equal than left hand operand
==                    - Loose value test that does not check expression data type
===                   - Strict value test by both value and data type. NOTE: NaN === NaN returns false
!==                   - Strict invert value test by both value and data type. NOTE: NaN !== NaN returns true
(expr) ? true : false - Ternary operator

Bitwise operators
------------------
||  - OR
&&  - AND
^   - XOR
~   - NOT
<<  - Zero fill left shift
>>  - Signed right shift
>>> - Zero fill right shift

NOTE: In JavaScript, bitwise operators always use automatic type conversion of number to 32-bit signed integer except
      zero fill right shift which makes number unsigned 32-bit integer

Spread / Rest operators
------------------------
Spread syntax allows an iterable object such as an array or string to be expanded in places where zero or more elements are
expected. Spread syntax allows using it multiple times while Rest syntax can only be used once. Rest syntax does the opposite
of Spread and condenses multiple elements into a single element. Rest syntax can only be used with function declaration as a
last parameter. Syntax for both are the same:

...  - Three dots (.) syntax is used for both: rest and spread operators. Both require iterable object but context where
       it is used, defines which terminology is correct.

Spread with arrays:

  var myArr  = ["x", "y", "z"];
  var spreadArr = [...myArr, "zz"];                     // newArr has following elements: ["x", "y", "z", "zz"]
  var secondSpreadArr = [...myArr, "foobar", ...myArr]; // Spread used two times, result: ["x", "y", "z", "foobar", "x", "y", "z"]

Example with Rest operator as functions last parameter and passing it array parameter with Spread operator:

  var myArr = [1, 2, 3];

  function restTest(param1, ...arbitraryNoOfArguments) {
    console.log(arbitraryNoOfArguments);
  }

  restTest(1, 2, "testing", 4);
  restTest(1, ...myArr);

  Console output:
   [2, "testing", 4]
   [1, 2, 3]

Other operators
----------------
* typeof
    Description:   Returns a string indicating the data type of the expression
    Return values: undefined, object, boolean, number, string, symbol, function, object, NaN, Infinity, -Infinity
    Example usage:

      var myNum = 7;
      console.log(typeof myNum);

      Console output:
       number

    NOTE: You cannot use typeof to determine if a JavaScript object is an array or a date

* instanceof
    Description:   Tests whether the prototype property of a constructor appears anywhere in the prototype chain of an object
    Return values: true or false
    Example usage:

      function myObj() {
        name: "Hunter S. Thompson";
      }

      var test = new myObj();
      console.log(test instanceof myObj);

    Console output:
     true

* void
    Description:   Evaluates an expression and returns undefined. Often used to obtain undefined primitive value. Can be used
                   with or withour parentheses, either void(0) or void 0
    Return value:  undefined
    Example usage:

      var a = 1, b = 2, c;
      console.log(void(c = a + b));
      console.log(c);

    Console output:
     undefined
     3

* delete
    Description:   Make an array elements value to undefined or remove an objects property.
                   NOTE: delete operator does not free memory, if so happens, it is merely a side-effect. JavaScript handles
                   garbage collection automatically and does not provide any way to free memory manually.
    Return value:  true or false
    Example usage:

      var myArray = [1,2,3];
      var myObj = {
        fname: "Hunter",
        lname: "Thompson",
        customArr: myArray;
      };

      console.log(myObj.fname);
      delete myObj.fname;
      console.log(myObj.fname);
      delete myObj.customArr[0];
      console.log(myObj.customArr[0]);

    Console output:
     Hunter
     undefined
     undefined


=== 2.3 Variables ===

Variable naming rules for JavaScript
-------------------------------------
* Variable name must start with a letter, dollar ($) or underscore (_)
* Variable name can contain letters, underscores, digits and dollar signs
* Keywords cannot be used as variable names

Variable names are case-sensitive. In JavaScript it is common practice to use lower camelCase when naming variables.
Multiple variables can be defined separated by comma (,) until a semicolon (;) ends statement. Even newlines are
acceptable:

var a, b = 1,
    c = "Some string";

-------------------------------------
2.3.1 Primitive Data Types
-------------------------------------

There are six primitive data types and Object data type. But with JavaScript, primitive data types are not primitive per se,
and have methods and properties also because when executing methods and properties JavaScript automatically treats
primitive data types as an Object data type.

* boolean
    Description: Can hold "true" or "false" value.

* undefined
    Description: If variable is not initialized but has been declared.

* null
    Description: Indicates that a variable points to no object or variable is "nothing" that does not exist.
                 NOTE: typeof null returns "object", not "null" for legacy reasons

* number
    Description: Unlike programming languages that have different types for numbers, ie: short (16bit integer), long (64bit integer),
                 float (64bit floating point) etc. JavaScript has only one type of number that is 64-bit signed floating point.

                 NOTE: Becouse JavaScript numbers are floating points, numbers are accurate up to 15 digits. Also floating point
                 calculations are not precise, for example: 0.1 + 0.2 = 0.30000000000000004. To overcome this, it helps to
                 multiply/divide: (0.1 * 10 + 0.2 * 10) / 10 = 0.3

                 Syntax for declaring number in hexadecimal format: 0xff       // 255
                 Syntax for declaring number in octal format:       0o377      // 255
                 Syntax for declaring number in binary format:      0b11111111 // 255

                 Octal format must start with zero followed by case insensitive letter o. So 0o1 is same as 0O1
                 Two special types of number literals exist, NaN (Not a Number) and Infinity/-Infinity.

                 NOTE: You can check NaN value with isNaN() -function and Infinity/-Infinity value with isFinite() -function.

* string
    Description: JavaScript strings are actually a collection of 16-bit integers using UTF-16 encoding. Unicode code point escape
                 codes for strings are supported since ECMAScript 6. You can access single character in a string with array style
                 indexing that starts from zero. For example:

                  var myStr = "This is a string";
                  console.log(myStr[0] + myStr[8]);

                  Console output:
                    Ta

                 Syntax for Unicode unit format: \uXXXX
                 Syntax for Unicode code point format: \u{XXXX}

                 NOTE: If you concatenate two strings with the plus (+) operator, with a left hand string ending with a high surrogate
                       code unit and right hand string starts with a low surrogate code unit, result will feature a surrogate code point.

                 You can use escape characters with strings preceding backslash (\) character:
                 \'      - Single quote
                 \"      - Double quote
                 \\      - Backslash
                 \b      - Backspace
                 \f      - Form Feed
                 \n      - New Line
                 \r      - Carriage Return
                 \t      - Horizontal Tabulator
                 \v      - Vertical Tabulator

                 With string data type, you can separate long text line to multiple lines in code with singe backslash (\) character.

                   var myStr = "This is a \
                                multiline string assignment";

* object
    Description: JavaScript is object orientated (pun intented) scripting language but has exception to many other programming
                 languages because there is no classes in JavaScript. You can emulate class with function but when it comes to
                 inheritance, objects inherit from other objects and not classes. You can also have "static" and "dynamic"
                 objects (actually all objects are dynamic in a way that you can add/remove any property from object at any time)
                 when declaring them. All JavaScript primitive data types can also be objects if defined with "new" keyword.
                 There are several ways to define an object. To define a method inside a class you use "function" declaration
                 syntax. To create objects, you can use following syntaxes:

                 1) Using the "new" keyword

                   var myMath = new Math();

                 2) Using an Object Literal

                   var myObj = {firstname: "Hunter", lastname: "Thompson", age: 70, printInfo: function(dummyParam = "Hello ") {
                                console.log(dummyParam + this.firstname + ' ' + this.lastname + ', age: ' + this.age);}};

                  Explanation:
                    Object Literal means that you both define and create an object in one statement.
                    Syntax for Object Literals:
                      object declaration starts with code block ie. two curly braces ({}). Methods/properties are written
                      in name:value pairs separated by comma (,). Spaces and line breaks are ignored so you could write
                      above example more readable:

                      var myObj = {
                        firstname: "Hunter",
                        lastname : "Thompson",
                        age      : 70,
                        printInfo: function(dummyParam = "Hello ") {
                                     console.log(dummyParam + this.firstname + ' ' + this.lastname + ', age: ' + this.age);
                                   }
                      };


                 NOTE: If you call printInfo -method without (), it will return the function definition as a string.

                 The "this" keyword can be used to access objects properties/methods inside object. Syntax to access object
                 methods/properties outside of Object declaration, you can use either the dot (.) operator or square braces
                 ([]) with property/method name surrounded by either double quotes (") or single quote ('). For example:

                   myObj.printInfo();
                   myObj["printInfo"]('Morning ');

                 In the above example, second line accesses myObj objects printInfo method using square braces with method
                 name and parameter passing is done after that like normal function parameter passing, inside parentheses.

                 As discussed in the operator section, you can delete Object properties/methods with keyword "delete" and
                 add new properties/methods dynamically:

                   delete myObj.printInfo;
                   myObj.printInfo = function() { console.log('This is a new method, firstname property of this object \
                                                               holds value: ' + this.firstname); };
                   myObj.printInfo();

                 Console output:
                  This is a new method, firstname property of this object holds value: Hunter


                 Unlike other variables, JavaScript Objects are mutable: They are addressed by reference, not by value.
                 So assigning two variables with the same object and accessing member variable with other will change
                 the value of the objects property. Following the above example:

                   var x = myObj;
                   x.age = 50;
                   console.log(x.age);
                   console.log(myObj.age);

                 Console output:
                  50
                  50

                 JavaScript supports "Method Chaining" syntax with objects, which means that when a method returns
                 a reference to object itself, you can use returned objects methods in chain with dot (.) operator.
                 For Example:

                   var myObj = {
                     name    : "",
                     setName : function(name) {
                       this.name = name;
                       return this;
                     },
                     getName : function() {
                       return this.name;
                     }
                   };

                   console.log(myObj.setName('Hunter S. Thompson').getName());

                 Console output:
                  Hunter S. Thompson

* symbol
    Description: ES6 introduced new primitive type: Symbol. Every symbol has a unique value. Symbols are only used for identifier for
                 object properties. You can create new symbol by calling Symbol() function that can take one string value as
                 parameter for debugging purposes only. Two most usefull methods when creating symbol are for() and keyFor().
                 When creating symbol with Symbol.for(stringKeyName), method either retrieves given parameter symbol or if not found,
                 creates new. Symbol.keyFor(symbol) is used to retrieve symbol key from global symbol registry by given symbol
                 parameter or returns undefined if not found.

                 NOTE: Do not use "new" keyword when creating symbol or you will get TypeError

                 Example 1:

                   var myObj = {
                     x: Symbol('debug info')
                   };

                   console.log(myObj);  // Outputs myObj with property x as "Symbol(debug info)"

                 Example 2:

                   var myObj = {
                     x     : '',
                     calc  : function(a, b) {
                               return a + b;
                             }
                   };

                   myObj.x = Symbol.for('calcObj');
                   console.log(Symbol.keyFor(myObj.x));  // Outputs "calcObj", using symbol as parameter
                   console.log(Symbol.for('calcObj'));   // Outputs "Symbol(calcObj)", using symbol key name as parameter


JavaScript is "loosely typed" or a "dynamic" language. Variables in JavaScript are not directly associated with any
particular value type, and any variable can be assigned and re-assigned values of all types. For example:

  var myVar = 22;    // myVar is number
  myvar     = "22";  // myVar is string
  myvar     = true;  // myVar is boolean

Re-Declaring variable does not make it lose its value.

-------------------------------------
2.3.2 Variable Scope
-------------------------------------

Basic behaviour
-------------------------------------

JavaScript has global and local scope for variables. Variables with global scope are accessible by all scripts and functions
in a web page. You can use keyword "var" for declaring variables but without using "strict mode", you can also omit the "var"
keyword. Normally variables declared inside a function or method belong to local scope and variables declared outside a
function or object belong to global scope but there are exceptions.

One of the exceptions is variables declared inside a function without "var" keyword and once you have called that function,
those variables belong automatically to global scope. If you try to access variables inside the function before calling
the function, you will get ReferenceError.

Example 1 - Global scope after calling function x():

  function x() {
    y = 3;
  }

  x();
  console.log(y);  // Outputs 3 as the value of y

Example 2 - Local scope using "var" keyword inside function:

  function x() {
    var y = 3;
  }

  x();
  console.log(y); // Outputs "Uncaught ReferenceError: y is not defined".


JavaScript variable scope has an upwards chain which means if you have function inside function, child function can access it's parent
functions local variables.

  function a() {
    var x = 1;
      function b() {
        console.log(x);
      }
    b(); // If we don't call child function, we get "ReferenceError"
  }
  a();  // Outputs 1 as the value of x


Hoisting
-------------------------------------
JavaScript's default behaviour of moving variable declarations with "var" keyword and function declarations to the top of the current
scope is called hoisting. This allows JavaScript to call functions before they are declared.

NOTE: Only declarations are hoisted, not initializations

Example 1:

  myFunc('Hello World');  // Outputs "Hello World"

  function myFunc(param) {
    console.log(param);
  }

Example 2:

  console.log(x);  // Outputs "undefined"
  x = 1;
  console.log(x); // Outputs 1
  var x;


ECMAScript 6 added new keyword "let" which allows variable creation that has smaller scope than function scope. It limits scope to
block scope ie. inside curly braces({}). Constants also share this same scope.

  var x = 1;
  {
    let temp = x;
  }

  console.log(x, temp);   // Outputs ReferenceError: temp is not defined

NOTE: In JavaScript, objects and functions are variables

Constants
-------------------------------------
ECMAScript 6 also introduced new keyword "const" that ensures that variable value can't be overridden. Constant variables in JavaScript
only work with primitive values. Constants have to be initialized upon declaration or SyntaxError occurs.

  const MY_CONSTANT = 1;
  MY_CONSTANT = 2;   // Trying to redeclare constant variable produces "TypeError: Assignment to constant variable"


Template Literals
------------------

ECMAScript 6 also introduced Template Literals that allow using expressions inside a string. Syntax is initializing string
using backticks (`) instead of single (') or double quotes (""). Expressions are insterted inside Template Literal string with
syntax: dollar sign ($) and curly bracers ({}), where expression comes inside curly bracers. You can also make function
calls through expression.

var myName = "Hunter S. Thompson";
var myDynStr = `My name is: ${myName} and my age is ${getAge()}. Expression returns: ${1 == 2}`;

console.log(myDynStr); // Outputs: "My name is: Hunter S. Thompson and my age is 70. Expression returns false"

function getAge() {
  return 70;
}

You can also use Template Literals as a parameter to functions. This is discussed later on charapter "Functions".

Strict mode
------------

ECMAScript Strict mode was introduced already at ES5 but it has only lately gain widespread implementation from major browsers.
You should be causious when using strict mode if you want to have backward support with older browser versions,
for example Internet Explorer below version 10.

Strict mode has different semantics from normal code:
* Eliminate some JavaScript silent errors by changing them to throw errors
* Phobit some syntax likely to be defined in the future versions of ECMAScript
* Prevent accidental creation of global variable by mistyping it and instead throws ReferenceError
* You can't delete undeletable properties with delete keyword (like delete Object.prototype)
* All properties of object must be uniquely named
* Function parameters must be uniquely named

Strict mode also makes some changes to making JavaScript a bit more secure. For example, when you use "this" keyword inside a
function, if it is not declared specifically, it used to belong to window object. With sctrict mode enabled, value of undeclared
this keyword is "undefined".

To enable Strict mode, you must use it as a first statement in either the whole JavaScript file or inside function declaration.
You can write statement with either quote(') or doube quotes (""): "use strict"; OR 'use strict';

Global scope for strict mode, first statement in JavaScript file:

'use strict';
var myVar = 1;

function myFunction() {
  myVar = 2;
  console.log('myVar: ' + myVar);
}

myFunction();   // Outputs 2 to console

Local scope inside function, must be first statement:

function myFunction() {
  'use strict';
  myVar = 2;  // With strict mode enabled, does not create a global variable
}

console.log('myVar: ' + myVar);   // Outputs ReferenceError; myVar is not defined to console


JavaScript modules
-------------------

ES6 introduced modules which are separate JavaScript files that you can include in your script. Modules have automatically
strict mode enabled.

At the time of writing this, modules are not yet fully supported by major browsers, even at latest versions.

You use modules with keywords: "import" and "export". There are two types of export, named and default. You can have
multiple named exports per module but only one default export.

To declare JavaScript module in HTML, use syntax: <script type="module" src="myJavaScriptFile.js">

Syntax for default export: export default variable/function declaration/object declaration

Syntax for named export is same, just omit the "default" keyword and you can export what you want at the end of the module file
with encapsulated to curly bracers ({}) separated by comma.

Example for default export:

File: index.html
  <script type="module" src="script.js">

File: script.js
  import customFunction from './mod-functions.js';   // We can rename default import to whatever we want
  customFunction();

File: mod-functions.js
  export default function checkConsole() {
    console.log('I am an default exported function');
  }

Console output:
  I am an default exported function


Example for named exports:

File index.html
  <script type="module" src="script.js">

File: script.js
  import {checkConsole, getAdd} from './mod-functions.js';
  checkConsole();
  console.log(getAdd());

File: mod-functions.js
  export function checkConsole() {
    console.log('I am an default exported function');
  }

  function getAdd(a = 1, b = 1) {
    return a + b;
  }

  export {getAdd};

Console output:
 I am an default exported function
 2

Explanation:
  As you can see from syntax, you can use export keyword either in front of exported item or add export statement to the end of the
  JavaScript file or use combination of both.

-------------------------------------------------
2.3.3 Arrays and Sets
-------------------------------------------------

In JavaScript arrays are a special type of objects. The typeof operator in JavaScript returns "object" for arrays. To overcome this, you can
use array objects in-build method Array.isArray(myArray) which will return true/false. Arrays use zero based index numbers inside square
brackets to access its elements. Syntax to declare array in different ways:

  var myArray = [2,"saab","volvo"]; // Creates an array with 3 elements that have initial values
  var myArray = new Array(4);       // Creates an array with 4 elements which values are all undefined
  var myArray = [];                 // Creates empty array with one element which value is undefined
  var myArray = [[1,2],2,3];        // Multidimensional array

Syntax to access array elements is brackets ([]) with index number:

  myArray[0];    // Returns first element of array
  myArray[0][0]; // Return fist element of 2 dimensional arrays first element

If array has an element that holds string as a value, you can access individual string characters using multiarray syntax:

  var myArray = ["This is string"];
  console.log(myArray[0][0] + myArray[0][1])  // Outputs "Th"

If you store objects inside array elements, you should access them by their property names syntax instead of dot syntax.

  var myArray = ["test", {"name":"Hunter S. Thompson"}];
  console.log(myArray[1]['name']);  // Outputs: Hunter S. Thompson

Because arrays are special type objects in JavaScript, arrays can hold also functions as their value. Consider following example:

  function foobar() {
    console.log("foobar");
  }

  var myArray = [foobar(), 2];
  myArray[0]; // runs function foobar()

Spread example
---------------
You can use spread syntax multiple times:

  var numArray = [2, 3, 4];
  var numArray2 = [6, 7, 8, 9];
  var finalArray = [ 1, ...numArray, 5, ...numArray2, 10];
  console.log(finalArray);

Console output:
 [1, 2, 3, 4, 5, 6, 7, 8, 9, 10]

Usefull array properties/methods:
----------------------------------
* length
    Description:     Returns number of array elements
    Return value:    Non zero based count of array elements (number)
    Example usage:

      var myArr = [1, 2, 3];
      console.log(myArr.length);

    Console output:
     3

* pop()
    Description:    Removes the last element from an array. This method changes the original array
    Return value:   The removed element from the array; undefined if the array is empty
    Example usage:

      var myArr = [1, 2, 3];
      console.log(myArr.pop());
      console.log(myArr);

    Console output:
     3
     [1,2]

* push(...newValues)
    Description:    Adds one or more elements to the end of an array. This method changes the original array
    Return value:   Non zero based count of array elements after adding element(s)
    Example usage:

      var myArr = [1];
      myArr.push(2, 3);
      console.log(myArr);

    Console output:
     [1, 2, 3]

* shift()
    Description:    Removes the first element from an array. This method changes the original array
    Return value:   Removed element
    Example usage:

      var myArr = [1, 2, 3];
      console.log(myArr.shift());
      console.log(myArr);

    Console output:
     1
     [2, 3]

* unshift(...newValues)
    Description:    Adds one or more elements to the beginning of an array. This method changes the original array
    Return value:   Non zero based count of array elements after adding elements(s)
    Example usage:

      var myArr = [1];
      console.log(myArr.unshift(3,2));
      console.log(myArr);

    Console output:
     3
     [3, 2, 1]

* slice(start, end)
    Description:    Returns an array with given zero based arguments as array indexes. Original array will not be
                    changed
    Parameters:     start - Integer
                      Zero based index where to start. If undefined, index is set to 0. If greater than original
                      array element count, an empty array is returned. If negative index is given as parameter,
                      offset is set to start counting from the end of the array elements towards beginning.
                    end (optional) - Integer
                      Zero based index before which to end extraction so slice extracts up to but not including
                      end index. If omitted, end is set to arrays element count. If negative index is given,
                      offset is set to start counting from the end of the array elements towards beginning.
    Return value:   Array containing the extracted elements
    Example usage:

      var myArr = [1, 2, 3, 4, 5, 6];
      console.log(myArr.slice(2, 4));

    Console output:
     [3,4]

* splice(start, deleteCount, ...items)
    Description:    Changes the contents of original array by removing existing elements and/or adding new elements
    Parameters:     start - Integer
                      Zero based index at where to start changing the original array. If greater than the length of
                      the array, index is set to the current length of the array (ie. last element)
                    deleteCount (optional) - Integer
                      Number how many elements should be removed from original array. If omitted or value is greater
                      than the length of the original array, then all array elements will be deleted. If set to 0
                      or false, no elements are removed. In this case, you should specify at least one new element
                      with items parameter
                    items (optional) - Mixed
                      Elements to add to original array, beginning from start parameter. If omitted, splice() method
                      only removes elements from array.
    Return value:   An array containing the deleted elements. If only one element is removed, an array of one
                    element is returned. If no elements are removed, an empty array is returned.
    Example usage:

      var myArr = [4, 5, 6];
      console.log(myArr.splice(0, false, 1, 2, 3));
      console.log(myArr);
      console.log(myArr.splice(3, 3));
      console.log(myArr);

    Console output:
     []
     [1, 2, 3, 4, 5, 6]
     [4, 5, 6]
     [1, 2, 3]


* concat(arrayToMerge)
    Description:    Merges two arrays together. Does not change original arrays
    Return value:   New array that holds values of both arrays
    Example usage:

      var myArr = [1, 2, 3], myArr2 = [4, 5, 6];
      console.log(myArr.concat(myArr2));

    Console output:
     [1, 2, 3, 4, 5, 6]

* indexOf(valueToSearch, startIndex)
    Description:    Finds first occurance of array value using strict equality (same as === operator)
    Parameters:     valueToSearch - Mixed
                      Value to locate in array
                    startIndex (optional) - Integer
                      Zero based index where to start searching value. If index is larger than number of array elements,
                      -1 is returned and no search will be done. Default value 0 (entire array is searched)
    Return value:   First index (zero based) of searched value or -1 if not found
    Example usage:

      var myArr = [1, 2, "foobar", 1];
      console.log(myArr.indexOf(1, 2));

    Console output:
      3


* lastIndexOf(valueToSearch, startIndex)
    Description:    Same as indexOf() but starts search from the end of array towards beginning
    Parameters:     valueToSearch - Mixed
                      Value to locate in array
                    startIndex (optional) - Integer
                      Array index from where to start searching from end towards beginning. Default value: array element count -1
                      so whole array is searched. If startIndex is greater than array element count, the whole array will be
                      searched.
    Example usage:

      var myArr = [1, 2, "foobar", 1];
      console.log(myArr.lastIndexOf(1));

    Console output:
      3

* join(separator)
    Description:    Joins all array elements into a string with given separator
    Parameters:     separator (optional) - String
                      A string which to use as separator when constructing string from array elements. If omitted,
                      default value is comma (,). If separator is an empty string, all elements are joined without
                      any characters in between them.
    Return value:   String that contains all array elements separated by separator parameter if given
    Example usage:

      var myArr = [1, 2, 3, "foobar!"];
      console.log(myArr.join('-'));

    Console output:
     1-2-3-foobar!

* map(callbackFunction(currentValue, index, array), thisArg)
    Description:    Runs callbackFunction to all array elements, starting from beginning of array. Does not modify the original array
    Parameters:     callbackFunction - Function name (String) or statement
                      Callback function will be provided three arguments by map() method:
                      currentValue - Mixed
                        Current value being processed in the array
                      index (optional) - Integer
                        Index number of the currently processing array element
                      array (optional) - Array
                        Original array that the map is processing
                    thisArg (optional) - Value to use as "this" when executing callback
    Return value:   Array with each element being the result of the callback function
    Example usage:

      var myArr = [1, 2, 3];
      console.log(myArr.map(value => value * 2));
      console.log(myArr.map(triple));

      function triple(value, index, array) {
        console.log('Multiplying array index: ' + index + ' value: ' + value + ' from array: ' + array + ' with 3');
        return value = value * 3;
      }

    Console output:
     [2, 4, 6]
     Multiplying array index: 0 value: 1 from array: 1,2,3 with 3
     Multiplying array index: 1 value: 2 from array: 1,2,3 with 3
     Multiplying array index: 2 value: 3 from array: 1,2,3 with 3
     [3, 6, 9]


For full list of array properties/methods, see [Ref. 2]


Sets
-------------------------------------------------
Set in JavaScript is almost same as array except set can only hold values that are unique and have their own properties bacause
sets, like arrays in JavaScript, are objects. Basic usage is to create new Set object and use its methods to manipulate set.
If you give parameters to Set object when creating it with new operator, you need to provide Iterator parameter like array.
Syntax to access set elements is same as in arrays, brackets ([]) with index number.

  var mySet = new Set([3, 4]);
  mySet.add(1);
  mySet.add(2);
  mySet.add(2);                 // Does not get added
  console.log(mySet.entries())  // Outputs: SetIterator "{3, 4, 1, 2}"

Usefull set properties/methods:
--------------------------------
* size
    Description:    Returns number of elements in a set, similar to Array.length
    Return value:   Non zero based integer of element count in set
    Example usage:

      var mySet = new Set();
      console.log(mySet.size);

    Console output:
     0

    NOTE:        Above example outputs 0 to console because we have not yet added any elements to set so it has zero elements

* add(value)
    Description:    Adds new value to set
    Parameter:      value - mixed
                      Appends new element to end of set. If set allready contains an element with same value, nothing happens.
    Return value:   Current set Object
    Example usage:

      var mySet = new Set([1]);
      console.log(mySet.add(2));

    Console output:
      {1, 2}

* delete(value)
    Description:    Removes element from set if it has element that holds same value as given parameter
    Return value:   True if successfull, false else
    Example usage:

      var mySet = new Set();
      mySet.add(1).add(2).add(3);
      console.log(mySet.delete(2));

    Console output:
      true

* clear()
    Description:    Removes all elements from a set Object
    Return value:   undefined
    Example usage:

      var mySet = new Set([1, 2, 3]);
      mySet.clear();
      console.log(mySet.size);

    Console output:
     0

* has(value)
    Description:    Searches set for given parameter value
    Return value:   true if element with same value as given parameter value exists, otherwise false
    Example usage:

      var mySet = new Set([1,3]);
      console.log(mySet.has(1));
      console.log(mySet.has(2));

    Console output:
     true
     false


For full list of set properties/methods, see [Ref. 3]


-------------------------------------------------
2.3.4 Type casting
-------------------------------------------------

JavaScript has automatic type casting whenever possible. Results may not always be what you expect:

  "5" + 2    // returns "52" because 2 is converted to string and then concatenated
  "5" - 2    // returns 3 because 5 is converted to integer
  "5" * "2"  // returns 10 because "5" and "2" are converted to integers

For manual type cast, you can use following JavaScript Objects
---------------------------------------------------------------
* Number(value)
    Description:    When used without "new" keyword, just like you would use function, converts given value to number data type
                    if possible.
    Return value:   value parameter converted into number data type, otherwise NaN
    Example usage:

      var myVar = "1", mySecondVar = 2;
      console.log(Number(myVar) + mySecondVar);

    Console output:
     3

* String(value)
    Description:    As with Number object, String object can be used like function when used without keyword new. Converts given value
                    to string data type if possible.
    Return value:   value parameter converted into string data type if possible
    Example usage:

      var myObj = {name:"Hunter S. Thompson"}, myVar = 150;
      console.log(String(myObj));
      console.log(String(myVar));

    Console output:
     [object Object]
     150

* Boolean(value)
    Description:    Following the two above examples, used in a function manner, converts value to boolean
    Return value:   true or false
    Example usage:

      var myNum = 1, mySecondNum = 0;
      console.log(Boolean(myNum));
      console.log(Boolean(mySecondNum));

    Console output:
     true
     false


Other type cast ways
---------------------
For strings, you can also use functions parseFloat(), which returns a floating point number from a string if possible and parseInt(), which
returns an integer value from a string if possible. Example:

  var myStr = "1.99.11";
  console.log(parseFloat(myStr));
  console.log(parseInt(myStr))

  Console output:
   1.99
   1

As you can see from console output, parseFloat() function takes only first dot (.) character into account and parseInt() function does
same.

Numbers can be converted to fixed decimal point using method toPrecision() which takes argument of number of decimals and returns result
rounded up.

  var myNum = 1.23456789;
  console.log( myNum.toPrecision(5));  // Outputs "1.2346"

Casting number to string can also be done using toString() method (but according to MDN web docs, String object used like a function is
better option [Ref. 4]):

  var x = 4;
  console.log(x.toString()); // Outputs "4"

We already covered how to type cast array to string but let's revise it. Use arrays join() method:

  var x = [1, 2, 3, 4];
  console.log(x.join());   // Outputs "1,2,3,4"
  console.log(x.join('')); // Outputs "1234"

-------------------------------------------------
2.3.5 Control Structures
-------------------------------------------------
Again, comparing to C++/Java, JavaScript has the following same basic control structures that both languages:

  if(value) {
  } else if(value) {
  } else {
  }

  switch(value) {
    case 'value':
      break;
    default:
      break;
  }

  for(value = initialized; value < endForLoop; value++) {
  }

  while(statement) {
  }

  do {

  }while(statement)


JavaScript specific control structures
---------------------------------------
JavaScript has for/in and for/of loops that are used to loop through objects properties.

for/in example usage:

  var myObj = {a:1,name:"test",calc:function(param1){return param1 + this.name;}};

  for(let property in myObj) {
	  console.log(property + ': ' + myObj[property]);
  }

Console output:
 a: 1
 name: test
 calc: function(param1){return param1 + this.name;}

NOTE: you can't use dot operator syntax! If you use console.log(myObj.x); it will output "undefined"

for/of uses right hand operands [Symbol.iterator] method and calls it for each iteration until it has no more iterations left.
So you have to have an iteration object to use for/of loop. Example usage:

  var myStr = "A string";

  for(let codeUnit of myStr) {
	  console.log(codeUnit);
  }

Console output:
 T
 e
 x
 t

-------------------------------------------------
2.3.6 Error handling
-------------------------------------------------

JavaScript supports try/catch error handling. Normal Error object is created with two properties: message and name. With keyword "throw",
you can create custom error messages. Keyword "finally" lets you execute code block regardless of the result. For example:

try {
  var x = 1;
  if( x != 0 )
    throw "X is not 0!";
} catch(Error) {
  console.log(Error);
} finally {
  console.log("this will be printed to console regardless if there was an error or not");
}

If you do not use custom error messages created by "throw" -keyword, JavaScript creates an Error object that has two properties:
"name" and "message". Six different values can be returned by the error name property:

EvalError       - An error has occurred in the eval() function
RangeError      - A number "out of range" has occurred
ReferenceError  - An illegal reference has occurred
SyntaxError     - A syntax error has occurred
TypeError       - A type error has occurred
URIError        - An error in encodeURI() has occurred


JavaScript can "display" data in four different ways, using object methods:
* Writing into an HTML element using innerHTML()
* Writing into HTML output using document.write()
* Writing into an alert box using window.alert()
* Writing into browser console for debugging purposes, using console.log()

====================================================
=== 3. Functions                                 ===
====================================================

Functions in JavaScript are quite versatile and differ quite a lot from other languages. JavaScript treats functions as Objects even
though typeof operator returns string "function". For example, JavaScript functions have properties and methods like: arguments.length
that returns the number of arguments passed to function when it was called and toString() -method that returns function declaration
as a string. So in basic, all functions in JavaScript are methods that belong to some object. If no object is defined, then
function belongs to BOM window object and becomes it's method after declaration. So when you declare a function, you can call it
by two different ways:

  function myFunction() {
    return 'foobar';
  }

  window.myFunction();
  myFunction();

JavaScript's default behaviour of moving declarations to the top of the current scope is called hoisting. Hoisting applies to variable
declarations and to function declarations. Bacause of this, JavaScript functions can be called before they are declared:

  myFunction(5);

  function myFunction(value) {
    console.log(value);
  }

Up until ES6, function arguments could not have a default value assigned and you would have to explicitly check the value before using it
inside a function.

  function calculate(param1, param2) {
	  if(typeof param1 === "undefined")
		  param1 = 1;
	  if(typeof param2 === "undefined")
		  param2 = 1;

	  return param1 + param2;
  }

  console.log(calculate(2)); // Will write 3 to console

NOTE: When you check parameters data type with typeof operator, notice that undefined is a string.

You can access passed parameters to function also with built-in object called "arguments" and even manipulate it so that it can actually "access"
parameters that were not defined in function definition.

  function calculate(param1, param2) {
    if(typeof arguments[0] === "undefined")
      arguments[0] = 1;
    if(typeof arguments[1] === "undefined")
      arguments[1] = 1;

    arguments[2] = 3;   // Add third nonexist argument with value of 3

    return arguments[0] + arguments[1] + arguments[2];
  }

  console.log(calculate(2));   // Will write 6 to console

From ES6 you can define parameters to have default values and even chain parameters.

  function calculate(param1 = 1, param2 = param1 + 1, param3 = param2 + 1) {
    return param1 + param2 + param3;
  }

  console.log(calculate());   // Will write 6 to console

Parameters are passed by value but if you pass object as parameter to function, then it is passed by reference.

You can have unlimited arguments with function using "Rest" argument in the function declaration. Rest argument is
prefixed with three dots "...". Rest argument behaves like an array so you can access additional arguments with array index.

  function calculate(...unlimitedParams) {
    return unlimitedParams[0] + unlimitedParams[1] + unlimitedParams[3];
  }

  console.log(calculate(2, 0, 0, 1));   // Will write 3 to console

You can also pass function parameters using rest syntax. So if you have an array that has 3 elements, following example is perfectly legal
in JavaScript:

  var myValues = [1, 2, 3];

  function calculate(param1, param2, param3) {
    return param1 + param2 + param3;
  }

  console.log(calculate(...myValues));   // Writes 6 to console

NOTE: If you would have an array with more elements than function takes arguments, only the first elements up until function parameter
      count (three in the above example) will be used and no error nor warning will be issued.

Tagged Template Functions
-------------------------------------------------

You can also call function with template literals. These functions are called "tagged template functions". Syntax for calling a tagged
template function differences a little bit from normal function call. You don't use parenthes () when you pass Template Literal String
as a parameter to function:

  var one = 1, two = 2, three = 3;
  count `Counting: ${one}... ${two}... ${three} done!`;

  // Tagged Template function
  function count(literalArray, ...values) {
    var helperString = "", i = 0;

    console.log(literalArray);
    for(let i = 0; i < literalArray.length; i++) {
      helperString += literalArray[i] + values[i];
    }
    console.log('Whole string, ' + helperString);
  }

Output to browser console:
 ['Counting: ', '...', '...', ' done!'];
 Whole string: Counting: 1... 2... 3 done!undefined

In the above example, first argument to Tagged Template function is array containing strings between variables inside Template Literal
String. For second argument we use spread operator and it holds an array with all the variable values inside Template Literal String.
Because there is only three variables inside Template Literal String (= three elements inside value rest argument) and four elements in
literalArray argument, looping through all elements that literalArray contains, causes the "undefined" to be printed to output.

Anonymous functions
-------------------------------------------------

Anonymous functions are functions without a name. You can create an anonymous function using an expression. Example of anonymous
function stored in a variable and the variable itself can be used as a function:

  var functionVar = function(a, b) { return a + b; };
  console.log('Anonymous function returns: ' + functionVar(1,2));

Console output:
 Anonymous function returns: 3

You can also create anonymous function with built-in JavaScript function constructor "Function()". Writing the above example to
produce same results with constructor class:

  var functionVar = new Function('a', 'b', 'return a + b');
  console.log('Anonymous function returns: ' + functionVar(1,2));

Console output:
 Anonymous function returns: 3

Anonymous functions can also be made "Self-invoking" which means that they are invoked (started) automatically without being called
if used as an expression. Syntax for this is adding parenthes and semicolon at the end of anonymous function. Consider the following
example:

  (function() { console.log('I am an Self-invoked anonymous function') })();

Console output:
 I am an Self-invoked anonymous function

The added parentheses around the function is so that it is an expression. Same results could be achieved with following example:

  console.log(function(){ return 'I am an Self-invoked anonymous function'; }() );

Console output:
 I am an Self-invoked anonymous function


ES6 also introduced shorthand definition of function syntax called "Arrow functions". Arrow functions are not named; they can be
assigned to a variable but are always anonymous. Syntax for Arrow functions has set of parentheses that hold parameters, then
arrow (=>) and finally curly braces ({}) that hold the body of the function.

  var calculate = (param1, param2) => { return param1 + param2; };
  var showText = () => { return "hello world!"; };

  console.log(calculate(1,2));   // Writes 3 to console
  console.log(showText());       // Writes "hello world!" to console


Immediately Invoked Function Expressions
-------------------------------------------------

Syntax: (function(){console.log('this will be run as soon the JS loading finishes')}());


Generator functions
-------------------------------------------------

Generator functions, introduced in ES6, are special functions that can be called and their execution can be left in a certain point and
continued from that point later. Generator functions use "yield" keyword for pausing the execution of function and returning a value until
the generator is called again and there are no more yields or a return keyword is executed which ends the function execution. Variable scope
is same as normal function and variables declared inside generator scope hold their value through every iteration call.

Syntax for creating a generator is same as normal function declaration except you use asterisk (*) in front of function name:

  function *myGenerator() {
    yield 'this is return value';
  }

You use generators through iterator object which is returned after the first call to generator. Iterator object itself has a method
"next()" that can have an argument. When you call generator function with iterator objects next() -method, an object with two
member variables is returned: "value" and "done". Objects value property holds yields return value (or return statements return value),
and done property holds true/false depending if the generator has reached end of it's execution.

To put this all together, we can have simple example:

  var myGen = myGenerator();  // myGen holds now an iterator object for myGenerator() -generator function

  // Loop through all iterations of generator or until return statement is reached and finishes generator
  do {
    var myObj = myGen.next();
    console.log('Generator return value: ' + myObj.value + ' / Generator finished: ' + myObj.done);
  } while(!myObj.done);
  console.log(myGen.next());  // Returns object {value: undefined, done: true}

  var myGen1 = myGenerator();  // Create new iterator object for generator function to use it again
  myObj = myGen1.next();
  console.log('New instance of generator iterator object created. Return value from calling generator: ' + myObj.value );

  // Generator function
  function *myGenerator() {
    var i = 0;

    i++;
    yield 'First call';
    yield 'Second call';
    i = i * i;
    return 'This is third call and return statement reached. i = ' + i;
    yield 'This is never executed because of above return statement';
  }

Output to browsers console:
 Generator return value: First call / Generator finished: false
 Generator return value: Second call / Generator finished: false
 Generator return value: This is third call and return statement reached. i = 1 / Generator finished: true
 {value: undefined, done: true}
 New instance of generator iterator object created. Return value from calling generator: First call


While you are able to pass argument to generator, it's a little tricky. You need to trigger the generator first with iteratorObj.next()
method and after that you can pass it an argument with iteratorObj.next(myArgument);

For example:

  var myGen = myGenerator();  // Obtain iterator object for generator
  var myObj = myGen.next();   // Iterate generator for the first time and obtain iterator object

  console.log(myObj.value);
  myObj = myGen.next('This is custom argument passed to generator');
  console.log(myObj.value);
  myObj = myGen.next();
  console.log(myObj.value);

  function *myGenerator() {
    var x = yield 'Generator called first time';
    yield x;
    yield 'generator finished';
  }

Output to browsers console:
 Generator called first time
 This is custom argument passed to generator
 generator finished


Function binding
-------------------------------------------------

Functions have a method called "bind()" that affects the scope of "this" keyword. This is called "bound function" or to be
exact, a bound function is an "exotic function object" (a term from ECMAScript 2015) that wraps the original function
object.

* bind(thisArg, ...arguments)
    Description:    Defines the scope of this -keyword with given parameter thisArg
    Parameters:     thisArg - object
                      Value to be passed as the this parameter to the target function when the bound function is
                      called. The value is ignored it the bound function is constructed using the new operator.
                    ...arguments - Mixed
                      Arguments to prepend to arguments provided to the bound function when invoked
    Return value:   A copy of the given function with the specified 'this' value and initial arguments
    Example usage:

      this.x = 9;  // this refers to global window object

      var boundFunction = {
        x    : 81,
        getX : function() { return this.x; }
      };

      boundFunction.getX();  // 81

      var retrieveX = boundFunction.getX; // When we take only function that uses 'this' operator, it belongs to global window object
      retrieveX();  // Returns 9

      // Create a new function with 'this' bound to boundFunction
      var boundGetX = retrieveX.bind(boundFunction);
      boundGetX();  // 81

====================================================
=== 4. Classes and Objects                       ===
====================================================

As we learned before, JavaScript actually treats every data type, even the primitive data types, as objects by automatically
type casting them to object data type in certain situations. One scenario would be that you want to know the how many
characters your string has:

  var myStr = "Hello World!";  // Data type is "String"
  console.log(myStr.length);   // JavaScript type casts string to object and you can access String objects length property
                               // which will return number 12

In other object oriented programming/scripting languages, you usually define class and then create an object from it.
JavaScript on the other hand, is classless language. With ES6, JavaScript now supports creating "classes" with new
keywords: class, super, extends, static and a method for class constructor called "constructor()". Because JavaScript
inheritance works by prototype chain in objects and not through classes, adding new keywords and functionality that
emulates classes is mainly syntactical sugar for those that have used to have classes in object oriented languages.

Before ES6, you could emulate classes by creating a function that acts as a constructor to new Object. using keyword
"this" inside function, our function acts like a class.

NOTE: Below example includes ES6 syntax with setting default values to function parameters if not provided when
      creating new object instance with "new" keyword.

    function Car(model = 'lada', color = 'red') {
      this.model = model;
      this.color = color;
      this.getCarInfo = getCarInfoOutside;
      this.setCarInfo = function(model = this.model, color) {
        this.model = model, this.color = color;
      }
    }

    function getCarInfoOutside() {
      return this.model + ': ' + this.color;
    }

    var myCar = new Car('Mercedes Benz', 'Red');
    myCar.setCarInfo('Mercedes Benz', 'Black');
    console.log(myCar.getCarInfo());

  Console log:
   Mercedes Benz: Black

  Explanation:
   First we create a function called car that can take two parameters. We initialize two variables which were
   passed as parameters to our "class" when creating instance of it with keyword new. Initializing model and car variables
   with keyword "this" makes them member variables of our "class". Then we create two methods and I intentionally made other
   method _outside_ of the "class" declaration and second one inside the "class" declaration. After creating object from "class",
   we decide to change the color of the car to Black instead of Red and finally we use method getCarInfoOutside() and pass it's
   return value to browsers console.


With ES6 there are keywords and syntax to write classes even if they are not classes in the same sense that in other scripting/programming
languages. If you are familiar with C++ or JAVA for example, this code snippet should look familiar:

  class Car {
    constructor(model = 'lada', color = 'red') {
      this.model = model;
      this.color = color;
    }

    set setModel(model) {
      this.model = model;
    }

    get getModel() {
      return this.model;
    }
  }

  class Mercedes extends Car {
    constructor() {
      super('Mercedes Benz');
      this.motor = "V4";
    }

    showMyCar() {
      console.log('I am driving a ' + this.color + ' ' + this.model + ' with ' + this.motor + ' engine');
    }

    static writeToConsole() {
      console.log('Static method called');
    }
  }

  var myCar = new Mercedes();   // Create new instance of Mercedes that is a sub-class of Car
  myCar.setModel = 'Ferrari';   // Use setter method
  myCar.showMyCar();            // Write to console: I am driving a red Ferrari with V4 engine
  Mercedes.writeToConsole();    // Example of static method


Things to remember with JavaScript classes
-------------------------------------------
* The class syntax does not introduce a new object-oriented inheritance model to JavaScript
* Classes are not hoisted
* The body of the class is executed in strict mode
* Keyword super can only be used in class constructor and must be called before keyword this can be used

You can find out more about classes in JavaScript in here [Ref. 6]https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Classes

-------------------------------------------------
4.1 Prototype Chain
-------------------------------------------------

Inheritance in JavaScript works through objects private property called "prototype", which is a pointer to another object.
That another object also has private property, prototype, that points to another object and so on until object's property
is found or prototype is null. This is called the "Prototype chain". On top of the prototype chain sits The Object from
which almost all JavaScript objects are instaces of. If you want to write complex code with good performance, it is essential
to understand JavaScript's prototype chain.

Let's take a couple examples of inheritance/prototype chain in JavaScript:

1) Basic prototype chain

  var trickHoisting = false;

  function simpleObj() {
    this.name            = "Elliot Alderson";
    this.age             = 28;
    this.switchHoisting  = function() { trickHoisting = true; }
  }

  var pChain = new simpleObj(); // Using new keyword with assignment statement, makes simpleObj a descendant of the Object
  console.log(pChain.toString());
  pChain.switchHoisting();

  if(trickHoisting)
    simpleObj.prototype.toString = function() { return 'Overrided Object.toString() method in prototype chain'; };

  console.log(pChain.toString());

Explanation:
 When we create new instance of simpleObj with new keyword, it becomes descendant of the Object. We then try to
 access method toString() which is not declared in simpleObj so JavaScript starts traversing the prototype chain:

 pChain.toString() not found --> pChain.prototype.toString() not found --> pChain.prototype.prototype.toString()
 found at Object.prototype.toString() so execute and end traversing prototype chain.

 Above example also uses a hack to avoid JavaScript hoisting for this example. We declare global variable
 "trickHoisting" which prevents hoisting in our example so that we can modify the prototype chain dynamically.
 After calling method switchHoisting() in our instance of simpleObj(), we change variable trickHoisting to true.
 This allows us to create custom toString() method to our simpleObj prototype. After this, prototype chain traverses:

 pChain.toString() not found --> pChain.prototype.toString() found so execute and end traversing prototype chain.


NOTE: This is also called method overriding


2) Method inheritance

JavaScript does not have methods in the same way as term is usually understood in object oriented languages. You create
"methods" in JavaScript adding function as a property of object. When an inherited "method" (function) is executed,
value of "this" keyword points to the inheriting object, not to the prototype object where the function is an own
property.

  function protoObj() {
    this.name    = "Hunter S. Thompson";
    this.age     = 60;
    this.getInfo = function() {
      return this.name + ': ' + this.age;
    }
  }

  var protoOrig = new protoObj();

  // Create new object using an existing object as a parameter to create new prototype property
  var protoInher = Object.create(protoOrig);
  protoInher.age = 80;

  console.log(protoOrig.getInfo());   // this refers to protoObj
  console.log(protoInher.getInfo());  // this refers to protoInher object

  Console output:
   Hunter S. Thompson: 60
   Hunter S. Thompson: 80

3) Property shadowing

Property shadowing is a term that simply means if you have declared a class that has a property and that class has a
prototype with same property, class property is used and not "shadowed" prototype property.

  function shadowExample() {
    this.name = "Hunter S. Thompson";
    this.age  = 70;
  }

  var myShadowExample = new shadowExample();
  shadowExample.prototype.age = 80;
  console.log(myShadowExample.age);   // Outputs 70

Overriding object constructor
-------------------------------

You can modify object constructor dynamically with objects prototype method. For example, using above "Class" Person and adding one property and
one method:

Person.prototype.address = "";
Person.prototype.getFullName = function() {
  return this.fname + " " + this.lname;
}

Different ways to create objects and the resulting prototype chain
-------------------------------------------------------------------
Objects created with syntax constructs:

  var noProtoObj = {foo: 'bar'};
  console.log(noProtoObj.__proto__);   // Check the console to see

Above example show through console that even though noProtoObj Object is a descendant of the Object, the Object's prototype
is null. Prototype chain: noProtoObj --> Object.prototype --> null

  var noProtoArr = ['foo', 'bar'];
  console.log(noProtoArr.__proto__.__proto__);

Above example shows prototype chain when using arrays. Arrays inherit from Array.prototype but without the new keyword,
prototype chain is: noProtoArr --> Array.prototype --> Object.prototype --> null

  function noProtoFunc() { return 'foobar'; }
  console.log(noProtoFunc.__proto__.__proto__);

Functions inherit from Function.prototype and again, without using the new keyword, prototype chain is:
noProtoFunc --> Function.prototype --> Object.prototype --> null


Objects with constructors in their declaration (must use new operator):

  function myConstructorExample() {
    this.name = "";
  }

  var constructorObj = new myConstructorExample();
  console.log(constructorObj.__proto__);   // Returns {constructor: f}

When you create object instance with new keyword, a constructor function for object is called. Above example's prototype
chain is: constructoObj.prototype


Using Object.create(). The prototype of this object is the first argument of the method:

  var createPrototypeForMe = {foo: 'bar'};
  var thxForCreating       = Object.create(createPrototypeForMe);
  var nullObj              = Object.create(null);
  var normalPrototype      = new String('foobar');
  var inheritedPrototype   = Object.create(normalPrototype);

  console.log(noPrototypeObj.__proto__);     // {constructor: f...}
  console.log(stillNoPrototype.__proto__);   // {foo: "bar"}
  console.log(nullObj.__proto__);            // undefined
  console.log(finallyPrototype.__proto__);   // String
  console.log(iHavePrototype.__proto__);     // String {"foobar"}

Object.create() global method creates a new instance of given object parameter and provides it with a prototype, just like with
using new keyword to create new object instance.


Using with JavaScript "Classes"
--------------------------------
  class Car {
    constructor(model, color) {
      this.model = model;
      this.color = color;
    }
  }

  class Mercedes extends Car {
    constructor(color) {
      super('Mercedes Benz', color);
    }

    get carInfo() {
      return this.model + ' - ' + this.color;
    }
  }

  var myCar = new Car();

Prototype chain with above example with classes is:
Car.prototype.constructor --> Mercedes.prototype.constructor --> Object.prototype --> null

Performance impact
-------------------

JavaScript allways traverses to the end of the prototype chain so if have long chain and you are trying to access a object property
that does not exist, the whole prototype chain is still traversed. Also, when iterating over the properties of an object, every
enumerable property that is on the prototype chain will be enumerated (prototype is looked recursively).

You can use Objects hasOwnProperty() -method to check if property exists in the current object and not traverse the prototype chain.


-------------------------------------------------
4.2 Proxies
-------------------------------------------------

JavaScript provides a Proxy Object that can be used to define custom behavior for fundamental operations like property lookup,
aggignment, enumeration, function invocation etc. in a target object. Proxy object uses so called "traps" to detect operation
on a target object and you can define custom behavior what happens when trap is executed.

You create a new Proxy object with normal object creation syntax with new keyword and two parameters, target and proxyhandler:

var proxiedObject = new Proxy(targetObj, handlerObj);

List of Proxy traps:
* getPrototypeOf()             - Object.getPrototypeOf
* setPrototypeOf()             - Object.setPrototypeOf
* isExtensible()               - Object.isExtensible
* preventExtensions()          - Object.preventExtensions
* getOwnPropertyDescriptor()   - Object.getOwnPropertyDescriptor
* defineProperty()             - Object.defineProperty
* has()                        - A trap for the "in" operator
* get()                        - A trap for getting property values
* set()                        - A trap for setting property values
* deleteProperty()             - A trap for the "delete" operator
* ownKeys()                    - A trap for Object.getOwnPropertyNames and Object.getOwnPropertySymbols
* apply()                      - A trap for a function call. NOTE: NOT for a method call
* construct()                  - A trap for the "new" operator

Example for using Proxy:

var Car = {
  name      : "Ferrari",
  color     : "Red",
}

var ProxyHandler = {
  get: function() {
    console.log('Proxy detected getting property value');
  },
  set: function(target, thisArg, argumentsList) {
    console.log('Proxy detected setting property value');
    target.color = "Black";
  },
}

var proxiedCar = new Proxy(Car, ProxyHandler);
proxiedCar.color = 'Yellow';
console.log(Car.color);

Console output:
 Proxy detected setting property value
 Black

[TODO]Proxy traps can also take parameters...

[TODO: explanation that apply only effects functions, not methods]


See APPENDIX: A for reference

-------------------------------------------------
4.3 Usefull Object properties/methods:
-------------------------------------------------

Let's have a closer look about common / usefull properties and methods of JavaScript standard built-in objects. I'm going
to cover only handfull of these objects, including primitive data types that are type casted to objects, Math, Date and
??? You can see full list from [Ref. 5]

* Object.seal(object)
    Description:    "Seales" given parameter object which means that it prevents adding/removing objects properties or
                    methods. Values of properties can still be changed though. Notice that you use global object
                    "Object" method seal().
    Parameter:      object - Object
                      The object to seal
    Return value:   Object that was passed to the method as parameter
    Example usage:

      var myObj = {
        name      : "Hunter S. Thompson",
        age       : 70,
        profession: "Journalist and Author",
        getValues : function() { return this.name + ': ' + this.age; }
      };

      delete(myObj.profession);
      Object.seal(myObj);
      myObj.addedProperty = "Silently fails";
      console.log(myObj.getValues() + ': ' + myObj.addedProperty);

    Console output:
     Hunter S. Thompson: 70: undefined

* Object.isSealed(object)
    Description:    Getter method to check if given parameter object is sealed
    Parameter:      object - Object
                      The object which sealed state to check
    Return value:   true/false
    Example usage:

      var myObj = {name:"Hunter S. Thompson"}, mySecondObj = {name:"Timothy Leary"};

      Object.seal(myObj);
      console.log('myObj is sealed: ' + Object.isSealed(myObj) + ' / ' + 'mySecondObj is sealed: ' + Object.isSealed(mySecondObj));

    Console output:
     myObj is sealed: true / mySecondObj is sealed: false

* Object.freeze(object)
    Description:    "Freezes" given parameterobject. Freezing means that it prevents objects properties and methods to be
                    added/modified/removed. Notice that you use global object "Object" method freeze().
    Parameter:      object - Object
                      The object to freeze
    Return value:   Object that was passed to the method as parameter
    Example usage:

      var myObj = {
        name      : "Hunter S. Thompson",
        age       : 70,
        getValues : function() { return this.name + ': ' + this.age; }
      };

      myObj.age = 60;
      console.log(myObj.getValues());
      Object.freeze(myObj);
      myObj.age = 70;  // Fails silently
      console.log(myObj.getValues());

    Console output:
      Hunter S. Thompson: 60
      Hunter S. Thompson: 60

    NOTE: You can also freeze an array

* Object.isFrozen(object)
    Description:    Getter method to check wether given parameter object is frozen
    Parameter:      object - Object
                      The object which frozen state to check
    Return value:   true/false
    Example usage:

      var myObj = {name:"Hunter S. Thompson"}, mySecondObj = {name:"Timothy Leary"};

      Object.freeze(myObj);
      console.log('myObj is frozen: ' + Object.isFrozen(myObj) + ' / ' + 'mySecondObj is frozen: ' + Object.isFrozen(mySecondObj));

    Console output:
     myObj is frozen: true / mySecondObj is frozen: false


For full list of methods and properties, see [Ref. 6]

Usefull JavaScript built-in objects
------------------------------------
Built in JavaScript constructors (Classes):
* Object();
* String();
* Number();
* Boolean();
* Array();
* RegExp();
* Function();
* Date();

For full list, see [Ref. 5]

===========================================
=== 5. HTML DOM (Document Object Model) ===
===========================================

When a web page is loaded, browser creates a HTML Document Object Model of the web page. HTML DOM is one of three W3C (World Wide Web Consortium)
DOM standards (other two are "Core DOM" and "XML DOM"). HTML DOM model is a tree of objects where root object is "document" and all HTML elements
are objects that belong to it. With JavaScript, you can modify, remove or add HTML elements, their properties and event handlers in a web page
dynamically. In other words, HTML DOM is a programming interface for HTML.

The document object represents your web page. If you want to access any element in the HTML page, you start with accessing the document object.

Good JavaScript programming practice is to wait for browser to fully load HTML DOM before trying to access HTML DOM elements. You also avoid
errors trying to access DOM element when browser has not rendered the whole page and created a DOM tree. This can be achieved with pure
JavaScript by using following code snippet:

      document.onreadystatechange = function() {
          if(document.readyState == 'complete' ) {
              // Place your code here
          }
      };

     OR

     window.onload = function() {
         // Place your code here
     }

Document objects onreadystatechange property changes during the page load. It can have following values:

* loading
    Document is still loading
* interactive
    Document has finished loading and has been parsed but sub-resourches such as images, stylesheets
    and frames are still loading
* complete
    Document and all sub-resources have finished loading. The state indicates that the load -event is
    about to fire

window.onload fires right after document -objects readyState -membervariable equals 'complete'.

=== 5.1 HTML DOM Basics ===

Accessing HTML elements
------------------------

To manipulate HTML elements with JavaScript, first you have to get object that represents HTML element. Depending on your needs,
you can retrieve HTML DOM object using HTML elements id, tag name, class name or CSS selector syntax. Folloding document object
methods are provided for this purpose:

* Getting HTML element object by id
    document.getElementById("myID");
      Return value: HTML element object which id equals given parameter
* Getting HTML elements objects by tag name
    document.getElementsByTagName("div");
      Return value: HTMLCollection object that holds all HTML elements that match given tag parameter
* Getting HTML elements by class name
    document.getElementsByClassName("myClass");
      Return value: Returns HTMLCollection object that holds all HTML elements that match given tag class name
* Getting HTML element by CSS selector string
    document.querySelector("#myId");
      Return value: HTML element with id "myId"
* Getting multiple HTML elements by CSS selector string
    document.querySelectorAll(".myClass");
      Return value: HTMLCollection object holding all elements with class name as "myClass"

After you have HTML element object, you can access its properties/methods. For example, changing a CSS style of one DIV in HTML document:

  var myDiv = document.getElementById("myID");
  myDiv.style.backgroundColor = "#000000";

If you use one of the document methods that return HTMLCollection object, you can access a single element in the same way you would
access an array element. For example, finding all HTML Div elements that have a class "myDIV" and changing their text:

  var myDivs = document.getElementsByClassName("myDiv");

  for(let i = 0; i < myDivs.length; i++ ) {
    myDivs[i].innerHTML = "This text was changed dynamically by JavaScript";
  }

=== 5.2 HTML DOM Events ===

You can use JavaScript to react HTML events. HTML Event can be something that browser or user does in web page. For example:

* An HTML web page has finished loading
* User clicks the mouse
* Mouse moves over the element
* User strokes a key
* A HTML input field has changed

Events can be written in the HTML document itself including event attribute to tag:

HTML File:
  <div>
    <p onclick="writeToConsole()">Click me</p>
  </div>
  <script>
    function writeToConsole() {
      console.log('P element clicked');
    }
  </script>

NOTE: If we use any of HTML elements event attribute, you have to have function declared in the same HTML file
      inside <script> tags.

Events can also be added dynamically with JavaScript:

  document.getElementById("myDiv").onmouseover = writeToConsole;

  function writeToConsole() {
    console.log('Mouse is over HTML element that has id myDiv');
  }

JavaScript propagates events in HTML DOM using either event bubbling or event capturing. Event propagation means in which order
should the event be handled. If we have element inside an element and both have mouseclick event attached to it, bubbling means
that inner most elements event handler is executed first, while capturing does the opposite (ie. outer most element's event
handler is executed first). To control even propagation, we can use elements "addEventListener" method:

* addEventListener(event, function, [options,useCapture])
    Description:    Attach event listener function to HTML element
    Parameters:     event - String
                      Event that we want to attach to HTML element.
                      NOTE: When adding event, we don't use the "on" prefix for the event like we would use in HTML. So
                            "onmouseclick" becomes "mouseclick".
                    function - String
                      Name of the function to execute when the event fires
                    options (optional) - Object
                      If given, takes object that specifies characteristics of the event listener. Avalaible options are:
                        capture: Boolean indicating that events of this type will be dispatched to the registered
                                 listener before being dispatched to any EventTarget beneath the DOM tree.
                        once:    Boolean indicating that the listener function to execute should be run only once
                                 after being added. If set to true, the listener will be automatically removed when
                                 invoked.
                        passive: Boolean that handles elements default behaviour. If set to to true and function to
                                 execute after event fires, calls preventDefault() method, a console warning will be
                                 issued.
                    useCapture (optional) - boolean
                      If set to true, event uses capturing propagation. If set to false, event uses bubbling propagation.
                      If options parameter is not given and boolean is given as a third argument, this argument takes
                      priority. Defaults to false ie. bubbling propagation.

    Return value:   undefined

    Example usage when clicked twice:

    HTML file:

    <div id="myDiv">
      <p id="myP">Click me</p>
    </div>

    JavaScript file:

    document.getElementById('myDiv').addEventListener('click', writeToConsole, true);
    document.getElementById('myP').addEventListener('click', writeToConsole, {once: true}, true);

    function writeToConsole() {
      console.log(this.id);
    }

    Console output:
     myDiv
     myP
     myDiv


By default, you cannot pass parameters to function which is executed when event fires. If you want to pass parameters to
function, you can use following example:

  function writeToConsole(text = "") {
    return function() {
      console.log(text);
    }
  }

  document.getElementById('myDiv').addEventListener('click', writeToConsole('Paramater passed'));


Common events:
onchange      - An HTML element has been changed
onclick       - The user clicks an HTML element
onmouseover   - The user moves mouse over an HTML element
onmouseout    - The user moves mouse away from an HTML element
onload        - The browser has finished loading the web page
onchange      - The event occurs when the content of a form element, the selection, or the checked state have changed (for <input>, <select>, and <textarea>)
onkeydown     - The event occurs when the user is pressing a key

Events can have properties and methods also:
preventDefault()   - Cancels the event if it is cancelable, meaning that the default action that belongs to the event will not occur
screenX            - Returns the horizontal coordinate of the mouse pointer, relative to the screen, when an event was triggered
target             - Returns the element that triggered the event


COMPLETE EVENT LIST:
abort
afterprint
animationend
animationiteration
animationstart
beforeprint
blur - element loses focus
canplay - when the browser can start playing media (when it has buffered enough to begin)
change - content of a form element changes (input, select, textarea)
click
contextmenu - when user right-clicks on an element to open a context menu
copy - when user copies content of an element
cut
dblclick
drag
dragend
dragenter - when the dragged element enters the drop target
dragleave - when the dragged element leaves the drop target
dragover - when the dragged element is over the drop target
dragstart
drop - when the dragged element is dropped on the drop target
durationchange - when the duration of the media is changed
ended - when the media has reach the end (like "thanks for listening")
error - when an error occurs while loading an external file
focus
focusin - fires just before focus, when the element is about to get focus
focusout
fullscreenchange - when an element is displayed in fullscreen mode
fullscreenerror - when an element can not be displayed in fullscreen mode
hashchange - when there has been chages to the anchor part of a URL
input - when an element gets user input
invalid - occurs when element is invalid
keydown
keypress
keyup
load - when an object has loaded
loadeddata - when media data is loaded
loadedmetadata - when meta data (like dimensions and duration) are loaded
loadstart - when browser starts looking for the specified media
message - when a message is received through the event source
mousedown
mouseenter
mouseleave
mousemove
mouseover
mouseout
mouseup - when a user releases a mouse button over an element
offline - when browser starts to work offline
online
open - when a connection with the event source is opened
pagehide - when the user navigates away from a webpage
pageshow - when the user navigates to a webpage
paste
pause
play
playing - event fires when media is playing after having been paused or stopped for buffering
popstate - fires when the windows history changes
progress - fires when the browser is in the process of getting the media data (downloading the media)
ratechange - when playing speed of the media is changed
resize - when document view is resized
reset - when a form is reset
scroll - when an elements scrollbar is being scrolled
search - when the user writes something in a search field (<input="search")
seeked
seeking
select - fires after the user selects some text (for <input> and <textarea>)
show - event occurs whe a <menu> element is shown as a context menu
stalled - fires when browser is trying to get media data, but data is not available
storage - fires when a Web Storage area is updated
submit - form is submitted
suspend - when browser is intentionally not getting media data
timeupdate - fires when the playing position has changed (like when the user fast forwards to a different point in the media)
toggle - when the user opens or closes <details> element
touchcancel - when the touch is interrupted
touchend - when a finger is removed form a touch screen
touchmove - when a finger is dragged across the screen
touchstart - when a finger is placed on a touch screen
transitioned - when a CSS transition has completed
unload - once a page has unloaded (for <body>)
volumechange
waiting - when the media has paused but is excepted to resume (like when the media pauses to buffer more data)
wheel - mouse wheel rolls up or down

For complete list of HTML DOM Events, see [ref.3]

===========================================
=== 6. BOM (Browser Object Model)       ===
===========================================

The Browser Object Model (BOM) in JavaScript is used to interact with the browser itself. It has one main
class called "window" which represents the browsers window. Every variable, class, function etc. you create
with JavaScript, becames a member of the window object. If HTML document contains frame or iframe, browser
creates additional window objects for each frame.

Even though there is no official standard for the BOM, almost all modern browsers have implemented same
methods and properties for JavaScript interactivity.

You can use shorthand syntax when using window object by omitting the window class in code. For example,
you can display alert box with syntax:

window.alert('This is an alertbox');

OR

alert('This is an alertbox');

Common methods of window object:
---------------------------------
* alert(message)                         - Displays alert box with message and OK button
* confirm(message)                       - Displays confirm box with message and OK and Cancel buttons
* prompt(message)                        - Displays prompt box asking user to input a string
* open(URL)                              - Opens a new window with given URL argument
* print()                                - Opens Print Dialog to print the current document
* getComputedStyle(element[, pseudoElt]) - Returns elements computed style
* scrollTo(x-coord, y-coord || options)  - Scrolls window to a particular place in the document
* location()

Method definitions
-------------------
Method:       alert(message)
Argument:     message (string) - optional
Description:  Displays the alert box containing message with ok button. If argument is array, method
              converts it into a string and displays array contents. NOTE: Prevents user from accessing
              other parts of the page until alert box is closed.
Return value: None

Method:       confirm(message)
Argument:     message(string) - optional
Description:  Displays confirm box containing message with ok and cancel buttons. If argument is array,
              method converts it into a string and displays array contents. NOTE: Prevents user from
              accessing other parts of the page until confirm box is closed.
Return value: true or false. If user clicked "ok", returns true, otherwise false.

Method:       prompt(message, defaultText)
Arguments:    message(string) - optional, defaultText(string) - optional
Description:  Displays prompt box containing message, text input field, ok and cancel buttons. If second
              argument is given, input field contains this argument. If either argument is array, method
              converts it into a string and displays array contents. NOTE: Prevents user from accessing other
              parts of the page until prompt box is closed.
Return value: String that user inputted. If cancel button is pressed, returns null.

Method:       open(URL, windowName, [windowFeatures])
Arguments:    URL(string) - optional
              windowName(string) - optional. Specifies the name of the browsing context (window, <iframe> or tab)
              [windowsFeatures](string) - optional. Comma separated list of freatures the new window should have
              with syntax "name=value". For example: "menubar=yes,location=yes,scrollbars=yes"
Description:  Opens a new browser window with given URL argument as location, with optional second argument, new window
              can be opened inside <iframe> or new tab. If third argument is used, opens window with given options
              according to third argument.
Return value: A window object representing newly created window. If the window could not be opened, return value is null.

Method:       print()
Arguments:    None
Description:  Opens browsers print dialog to print the current document.
Return value: None

Method:       getComputedStyle(element[, pseudoELT])
Arguments:    element(DOM element) DOM element which computed style to retrieve
              pseudoELT(string) - optional. A string specifying pseudo-element to match. Must be omitted (or null) for
              regula elements.
Description:  Used to get CSS style declarations for a single HTML element (or pseudo-element).
Return value: CSSStyleDeclaration object which updates itself automatically when the elemtns style is changed.
              NOTE: you can access elements CSS style properties either APIs provided by this object or simply indexing
              with CSS property name.

Method:       scrollTo(x-coord, y-coord || options)
Arguments:    If given x-coord(int) and y-coord(int), scrolls window in pixels to given argument values.
              If given options, you must define class that has 3 properties: top (same as x-coord), left (same as y-coord),
              behavior(string) that can have one of three values: smooth, instant or auto.
Description:  Scrolls viewport to given arguments.
              NOTE: If content fits to viewport and there is no scrollbars, this method does nothing.
              NOTE2: Atleast with Google Chrome (v69.0.3497.81) if not used with event handler, does nothing
Return value: None

Full list of window methods and properties: https://developer.mozilla.org/en-US/docs/Web/API/Window

=== 6.1 BOM Specific objects ===

Window object has 5 main classes as member variables, that also include DOM:

1. document
2. history
3. screen
4. navigator
5. location

Window.document
----------------

====================================================
=== 7. AJAX and JSON                             ===
====================================================

=== 7.1 JSON ===

JSON stands for JavaScript Object Notation and is a lightweight, platform independent, data interchange format. Most often used for sending
data to/from server. Basic syntax includes name/value pairs in double quotes separated by colon. If more than one name/value pair exists,
they are separated by comma. JSON is in text format and when exchanging data between a browser and a server, the data can only be in text
format. Benefits are that JSON data format is supported by far most of programming/scripting languages.

JSON format was originally specified by Douglas Crockford.

NOTE: JSON format requires use of name/value pairs to be enclosed in double quotes (")

Example: "name":"value","name1":"value1"

* Data is in name/value pairs
* Data is separated by commas
* Curly braces hold objects
* Square brackets hold arrays
* File type for JSON files is ".json" and MIME type is "application/json"

So a JSON data that holds object called "myObject", member variable "name" and array "colors":
{
  "myObject":{"name":"john", "colors":["green","red"] }
}

Another example, JSON received text data that contains simple data values

{
  "name":"McGuyver","age":30,"pro":true
}

JavaScript offers class with methods to easily convert JSON text data to JavaScript object.

JSON.stringify(myObject); // Converts object into JSON string
JSON.parse(myObject);     // Converts JSON string into a JavaScript object

=== 7.2 AJAX ===

AJAX is a technique to transfer data between web servers using users browser. AJAX is an acronym for Asynchronous JavaScript And XML.
With AJAX, you can update web page asynchronously in the background without reloading the whole page. AJAX uses an XMLhttpRequest Object
to request data from a web server. All modern browsers support XMLHttpRequest Object.

AJAX request could be broken into following steps:
1) An event triggers in a web page
2) A XHMLHttpRequest Object is create by JavaScript
3) XMLHttpRequest Object send a request to a web server
4) Server processes the request
5) Server sends response back to web page
6) Response is read with JavaScript
7) If request was successfull and server sent data, you can use it as you see fit (like updating a div content with latest news)

After creating XMLHttpRequest Object with new keyword, you have access to following methods/properties:

XMLHttpRequest object methods/properties
-----------------------------------------
* open(methodType, url, async)
    Description:    Specifies the type of request
    Parameters:     methodType - String
                      POST or GET
                    url - String
                      Universal Resource Location where to send request
                    async - Boolen
                      If set to true, request is made asynchronously, otherwise synchronous. Mostly suggested to use
                      asynchronous way so that JavaScript does not stop script execution while waiting reponse from
                      the server.
    Example usage:

      var myAjax = new XMLHttpRequest();
      myAjax.open("GET", 'www.mydomain.com/foobar.txt', true);

* send() / send(data)
    Description:    If parameter is provided, send() -method is used for POST, otherwise GET is used.
    Parameter:      data - String
                      Can be anything as long it is string.
    Example usage:

      var myAjax = new XMLHttpRequest();
      myAjax.open("POST", 'www.mydomain.com/foobar.txt', false);
      myAjax.send("myAPIKey=jklXS19dK");

* readyState
    Description:    Property that holds the status of the XMLHttpRequest
                    0: request not initialized
                    1: server connection established
                    2: request received
                    3: processing request
                    4: request finished and response is ready

* status
    Description:    Property that holds a HTTP status code. For example, HTTP 200 means "OK", 404 means "Page not found" etc.

* statusText
    Description     Property that holds the status code in a text format

* onreadystatechange
    Description:    Needs to be initialized with a function to be called when readyState property changes
    Example usage:

      var myAjax = new XMLHttpRequest();
      myAjax.onreadystatechange = function() {
        if(this.readyState == 4 && this.status == 200 )
          console.log(this.responseText);
      };
      myAjax.open("POST", 'www.mydomain.com/foobar.txt', false);
      myAjax.send("myAPIKey=jklXS19dK");

    Explanation of above example. Because onreadystatechange() event is triggered four times, one time for each change in the
    readyState property chain, an anonymous function is executed which tests for a objects readyState and status properties.
    If readyState property equals 4 (request is finished and response is ready) and status is HTTP code 200 (OK), our request
    was succesfully processed and answered. After this you can use two following properties to get the data (if any was sent).

* responseText
    Description:    Property that holds the servers response as a JavaScript string
    Example usage:

      Based on above example, you could retrieve data simply:
      document.getElementById('myDiv').innerHTML = myAjax.responseText;

* responseXML
    Description:    Property that holds the server response in a XML DOM Object format

====================================================
=== 8. Extras (RegExp, cookies...)               ===
====================================================

=== 8.1 Regular Expressions ===

JavaScript implements it's own RegExp syntax, built in language as an global object. You can create RegExp object using two ways which both hold their ups
and downs. With literal syntax, you're unable to add flags to pattern and you have to use forward (/) slashes to start and end pattern as in other languages.
With Regular Expression objects constructor, which takes string pattern as a first parameter, where you don't use beginning and ending forward slashes(/),
and flags as a second parameter. You can use RegExp objects prototype methods with both syntaxes. TIP: It's always a good practice to re-use pattern by saving
it to variable if possible for increasing performance.

NOTE: Do not use Regular Expressions inside a while loop

1. Using a Regular Expression literal which holds RegExp pattern inside forward slashes (/).
   For Example:
      var myRegExp = /[0-9]/;

      console.log(myRegExp.exec('here is 4 letters'));

  With this approach, you are able to use Regular Expression

2. Creating a new Regular Expression Object with first argument being a pattern as an string without forward slashes and flags for pattern as a second.

   For Example:
      var pattern   = /[0-9]/;
      var myRegExp1 = new RegExp('[0-9]');
      var myRegExp2 = new RegExp(pattern, 'g');

      console.log(myRegExp1.exec('here is 4 letters'));
      console.log(myRegExp2.exec('here is 4 letters'));

With both above examples, pattern is found and exec() -method returns an array which we print to console.


* Object.seal(object)
    Description:    "Seales" given parameter object which means that it prevents adding/removing objects properties or
                    methods. Values of properties can still be changed though. Notice that you use global object
                    "Object" method seal().
    Parameter:      object - Object
                      The object to seal
    Return value:   Object that was passed to the method as parameter
    Example usage:

      var myObj = {
        name      : "Hunter S. Thompson",
        age       : 70,
        profession: "Journalist and Author",
        getValues : function() { return this.name + ': ' + this.age; }
      };

      delete(myObj.profession);
      Object.seal(myObj);
      myObj.addedProperty = "Silently fails";
      console.log(myObj.getValues() + ': ' + myObj.addedProperty);

    Console output:
     Hunter S. Thompson: 70: undefined

Common Regular Expression prototype methods/properties
-------------------------------------------------------
* RegExp.exec(string)
    Description:    Executes Regular Expression against given string
    Parameter:      String to test - String
    Return value:   The returned array has the matched text as the first item, and then one item for each capturing parenthesis that matched containing
                    the text that was captured. Returns null on failure.
    Example usage:

      // Todo
      // todo

    Console output:
     // Todo

* RegExp.test(string)
    Description:    Executes Regular Expression against given string
    Parameter:      String to test - String
    Return value:   True if pattern is found in given argument, false otherwise.
    Example usage:

      // Todo
      // todo

    Console output:
     // Todo


-------------------------------
Regular Expression Cheat Sheet
-------------------------------

Flags

g - Global search. Continues searching after first match
i - Case-insensitive search
m - Multi-line search.
u - Unicode; treat a pattern as a sequence of unicode code points
y - perform a "Sticky" search that matches starting at the current position in the target string.

sticky; matches only from the index indicated by the lastIndex property of this regular expression in the target string (and does not attempt to match from any later indexes).

Note that the flags are an integral part of a regular expression. They cannot be added or removed later.

Character Classes
------------------
.    - The dot. Matches any single character
^    - Matches beginning of
$    - Matches end of
[]   - A character set. Matches any one of the enclosed characters. [abyh], [a-z0-9]
|    - Or. /green|red/
()   - Grouping
*    - Matches the preceding expression 0 or more times
+    - Matches the preceding expression 1 or more times
?    - Matches the preceding expression 0 or 1 time
{}   - Multiple syntaxes. Matches either exactly x occurances preceding expression: a{2} or matches atleast x occurances a{2,} or matches atleast x occurances and max. y occurances
       a{1,3}
\d   - Matches any digit. Equivelant to [0-9]
\w   - Matches all alphanumeric character including the underscore. Equivelant to [A-Za-z0-9_]

Examples:
----------

Finding and counting multiple occurances:
  var targetStr  = 'This is a sentence with s characters';
  var expression = /s+/g;
  var i = 0;

  while((found = expression.exec(targetStr)) !== null) {
    i++;
    console.log('"s" found at pos: ' + found['index'] + '. Count: ' + i);
  }

E-mail validation (clumsy example):
  var targetStr  = 'rick.morty+fw@mailbox.net';
  var expression = /([\w\.][^@!#\$%&'\*\/\=\?\^`\{\|\}~;]{1,64})([@]{1})([\w\.]{1,252})([^@!#\$%&'\*\/\=\?\^`\{\|\}~;][a-zA-Z]{2,3})/gi;
  var valid      = expression.exec(targetStr);

  console.log(targetStr);
  console.log(valid !== null ? 'E-mail address is valid' : 'E-mail address is invalid!');


=== 8.2 Cookies ===

Cookies are a way to store information on users browser when he visits website but only if he has allowed browser to
set cookies from website via browsers settings. Technically cookies are simple text files that browser store in users
computer in a single name=value pair as a content (value is String type). Because HTTP protocol is a stateless protocoll,
cookies are typically used to keep user logged in at a website, remember shoping cart contents in a webshop etc.

Cookies can have following optional parameters with required cookie name and cookie value parameters, used in a same
syntax as setting cookie ie. name=value separated by semicolon(;). All optional parameters must be in a one string:

* Domain / Path - These define the scope of the cookie. Default value for most browsers are root path and current domain
* Expiration Date - When browser deletes cookie
*
*

To create/modify/delete cookies with JavaScript you can use window.document.cookie -property.

Example to create cookie and creating cookie with optional parameters:

document.cookie = "username=Hunter S. Thompson; expires=Mon, 20 Jan 2020 12:00:00UTC; path=/";

To delete cookie with JavaScript, simply set expires parameter to past. NOTE: Some browsers will not let you delete a
cookie if you don't specify the path also:

document.cookie = "username=; expires=Thu, 01 Jan 1970 00:00:00 UTC; path=/"

To modify existing cookie, just use same name=value pair with new parameters and/or parameter values:

document.cookie = "username=Hunter S. Thompson; path=/images; domain=www.mywebsite.com";

To read all cookies with JavaScript:

var cookies = document.cookie;   // Using shorthand syntax, omitted window object. Returns all cookies in a one string:
                                 // cookie1=value;cookie2=value;cookie3=value...

Parameter examples:
--------------------
Parameter:     domain
Description:   Sets domain that cookie is valid for. You can set it to whole website (www.mywebsite.com) a subdomain
               (test.mywebsite.com) or all subdomains included in website (.mywebsite.com) with path=/ -parameter
Usage:         document.cookie = "name=Hunter S. Thompson; domain=www.mywebsite.com";
Notes:         If omitted, most browsers set domain as current URL [???]

Parameter:     path
Description:   Sets path in the website to which cookie is only valid for. Relative to domain[???]
Usage:         document.cookie = "name=Hunter S. Thompson; path=/images"
Notes:         If omitted, most browsers set "path=/" which covers all sub-directories in the website structure

Parameter:     expires
Description:   When cookie expires and browser removes it from users computer
Usage:         [???]


=================================================
=== 9. References                             ===
=================================================
1. Ecma International (Computer systems standards organization)
     [https://en.wikipedia.org/wiki/Ecma_International]
2. MDN (Mozilla Developer Network): JavaScript Arrays
     [https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/Array]
3. MDN (Mozilla Developer Network): Set
     [https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/Set]
4. MDN  (Mozilla Developer Network): Global Object String
     [https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/String]
5. MDN (Mozilla Developer Network): Standard built-in objects
     [https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects]
6. MDN (Mozilla Developer Network): Standard built-in objects - Object
     [https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/Object]
3. W3C (Word Wide Web Consortium): HTML DOM Event list
     [https://www.w3schools.com/jsref/dom_obj_event.asp]
